"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""
import builtins
import collections.abc
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.message
import sys
import toop_engine_interfaces.messages.protobuf_schema.optimizer.ac_dc_commons_pb2

if sys.version_info >= (3, 8):
    import typing as typing_extensions
else:
    import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

class BatchedMEParameters(google.protobuf.message.Message):
    """=====================================================
    BATCHED MAP-ELITES (GENETIC ALGORITHM) PARAMETERS
    =====================================================

    Parameters for starting the batched genetic algorithm (Map-Elites) on the GPU.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    SUBSTATION_SPLIT_PROB_FIELD_NUMBER: builtins.int
    SUBSTATION_UNSPLIT_PROB_FIELD_NUMBER: builtins.int
    DISCONNECT_PROB_FIELD_NUMBER: builtins.int
    RECONNECT_PROB_FIELD_NUMBER: builtins.int
    N_SUBS_MUTATED_LAMBDA_FIELD_NUMBER: builtins.int
    PROPORTION_CROSSOVER_FIELD_NUMBER: builtins.int
    CROSSOVER_MUTATION_RATIO_FIELD_NUMBER: builtins.int
    TARGET_METRICS_FIELD_NUMBER: builtins.int
    OBSERVED_METRICS_FIELD_NUMBER: builtins.int
    ME_DESCRIPTORS_FIELD_NUMBER: builtins.int
    RUNTIME_SECONDS_FIELD_NUMBER: builtins.int
    ITERATIONS_PER_EPOCH_FIELD_NUMBER: builtins.int
    RANDOM_SEED_FIELD_NUMBER: builtins.int
    CELL_DEPTH_FIELD_NUMBER: builtins.int
    PLOT_FIELD_NUMBER: builtins.int
    MUTATION_REPETITION_FIELD_NUMBER: builtins.int
    N_WORST_CONTINGENCIES_FIELD_NUMBER: builtins.int
    substation_split_prob: builtins.float
    """The probability to split an unsplit substation.
    If not split, a reconfiguration is applied.
    """
    substation_unsplit_prob: builtins.float
    """The probability to reset a split substation to the unsplit state."""
    disconnect_prob: builtins.float
    """The probability to disconnect a new branch."""
    reconnect_prob: builtins.float
    """The probability to reconnect a disconnected branch.
    This will overwrite a possible disconnect.
    """
    n_subs_mutated_lambda: builtins.float
    """The expected number (λ) of substations to mutate in a single iteration.
    Drawn from a Poisson distribution with this lambda.
    """
    proportion_crossover: builtins.float
    """The proportion of the first topology to take in the crossover."""
    crossover_mutation_ratio: builtins.float
    """The ratio of crossovers to mutations."""
    @property
    def target_metrics(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___TargetMetric]:
        """The list of metrics to optimize for with their weights."""
    @property
    def observed_metrics(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.str]:
        """The observed metrics — i.e. which metrics are computed for logging purposes.
        The target_metrics and me_descriptors must be included in the observed metrics.
        They will be added automatically if missing.
        """
    @property
    def me_descriptors(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[toop_engine_interfaces.messages.protobuf_schema.optimizer.ac_dc_commons_pb2.DescriptorDef]:
        """The descriptors to use for MAP-Elites.
        Each defines a metric determining the cell index and a number of cells.
        If a metric exceeds num_cells, it is clipped to the highest cell index.
        Must correspond to integer metrics.
        """
    runtime_seconds: builtins.float
    """The runtime in seconds for the optimization."""
    iterations_per_epoch: builtins.int
    """The number of iterations per epoch."""
    random_seed: builtins.int
    """The random seed to use for reproducibility."""
    cell_depth: builtins.int
    """When applicable, each cell contains cell_depth unique topologies.
    Use 1 to retain the original Map-Elites behavior.
    """
    plot: builtins.bool
    """Whether to plot the repertoire."""
    mutation_repetition: builtins.int
    """Increases the chance of unique mutations by mutating multiple copies of the repertoire."""
    n_worst_contingencies: builtins.int
    """The number of worst contingencies to consider in the scoring function.
    Used to determine the worst overload cases.
    """
    def __init__(
        self,
        *,
        substation_split_prob: builtins.float = ...,
        substation_unsplit_prob: builtins.float = ...,
        disconnect_prob: builtins.float = ...,
        reconnect_prob: builtins.float = ...,
        n_subs_mutated_lambda: builtins.float = ...,
        proportion_crossover: builtins.float = ...,
        crossover_mutation_ratio: builtins.float = ...,
        target_metrics: collections.abc.Iterable[global___TargetMetric] | None = ...,
        observed_metrics: collections.abc.Iterable[builtins.str] | None = ...,
        me_descriptors: collections.abc.Iterable[toop_engine_interfaces.messages.protobuf_schema.optimizer.ac_dc_commons_pb2.DescriptorDef] | None = ...,
        runtime_seconds: builtins.float = ...,
        iterations_per_epoch: builtins.int = ...,
        random_seed: builtins.int = ...,
        cell_depth: builtins.int = ...,
        plot: builtins.bool = ...,
        mutation_repetition: builtins.int = ...,
        n_worst_contingencies: builtins.int = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["cell_depth", b"cell_depth", "crossover_mutation_ratio", b"crossover_mutation_ratio", "disconnect_prob", b"disconnect_prob", "iterations_per_epoch", b"iterations_per_epoch", "me_descriptors", b"me_descriptors", "mutation_repetition", b"mutation_repetition", "n_subs_mutated_lambda", b"n_subs_mutated_lambda", "n_worst_contingencies", b"n_worst_contingencies", "observed_metrics", b"observed_metrics", "plot", b"plot", "proportion_crossover", b"proportion_crossover", "random_seed", b"random_seed", "reconnect_prob", b"reconnect_prob", "runtime_seconds", b"runtime_seconds", "substation_split_prob", b"substation_split_prob", "substation_unsplit_prob", b"substation_unsplit_prob", "target_metrics", b"target_metrics"]) -> None: ...

global___BatchedMEParameters = BatchedMEParameters

class TargetMetric(google.protobuf.message.Message):
    """A target metric and its weight in the optimization objective."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    METRIC_FIELD_NUMBER: builtins.int
    WEIGHT_FIELD_NUMBER: builtins.int
    metric: builtins.str
    """The metric name."""
    weight: builtins.float
    """The weight assigned to this metric."""
    def __init__(
        self,
        *,
        metric: builtins.str = ...,
        weight: builtins.float = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["metric", b"metric", "weight", b"weight"]) -> None: ...

global___TargetMetric = TargetMetric

class LoadflowSolverParameters(google.protobuf.message.Message):
    """=====================================================
    LOADFLOW SOLVER PARAMETERS
    =====================================================

    Parameters for the DC loadflow solver.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    MAX_NUM_SPLITS_FIELD_NUMBER: builtins.int
    MAX_NUM_DISCONNECTIONS_FIELD_NUMBER: builtins.int
    BATCH_SIZE_FIELD_NUMBER: builtins.int
    DISTRIBUTED_FIELD_NUMBER: builtins.int
    CROSS_COUPLER_FLOW_FIELD_NUMBER: builtins.int
    max_num_splits: builtins.int
    """The maximum number of splits per topology."""
    max_num_disconnections: builtins.int
    """The maximum number of disconnections to apply per topology."""
    batch_size: builtins.int
    """The batch size for the genetic algorithm."""
    distributed: builtins.bool
    """Whether to run the genetic algorithm distributed over multiple devices."""
    cross_coupler_flow: builtins.bool
    """Whether to compute cross-coupler flows."""
    def __init__(
        self,
        *,
        max_num_splits: builtins.int = ...,
        max_num_disconnections: builtins.int = ...,
        batch_size: builtins.int = ...,
        distributed: builtins.bool = ...,
        cross_coupler_flow: builtins.bool = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["batch_size", b"batch_size", "cross_coupler_flow", b"cross_coupler_flow", "distributed", b"distributed", "max_num_disconnections", b"max_num_disconnections", "max_num_splits", b"max_num_splits"]) -> None: ...

global___LoadflowSolverParameters = LoadflowSolverParameters

class DCOptimizerParameters(google.protobuf.message.Message):
    """=====================================================
    DC OPTIMIZER PARAMETERS
    =====================================================

    The set of parameters that are used exclusively by the DC optimizer.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    GA_CONFIG_FIELD_NUMBER: builtins.int
    LOADFLOW_SOLVER_CONFIG_FIELD_NUMBER: builtins.int
    DOUBLE_LIMITS_FIELD_NUMBER: builtins.int
    SUMMARY_FREQUENCY_FIELD_NUMBER: builtins.int
    CHECK_COMMAND_FREQUENCY_FIELD_NUMBER: builtins.int
    @property
    def ga_config(self) -> global___BatchedMEParameters:
        """The configuration options for the genetic algorithm."""
    @property
    def loadflow_solver_config(self) -> global___LoadflowSolverParameters:
        """The configuration options for the loadflow solver."""
    @property
    def double_limits(self) -> toop_engine_interfaces.messages.protobuf_schema.optimizer.ac_dc_commons_pb2.DoubleLimitsSetpoint:
        """The double limits for the optimization, if they should be updated."""
    summary_frequency: builtins.int
    """The frequency to push back results, based on number of iterations.
    Default is after every 10 iterations.
    """
    check_command_frequency: builtins.int
    """The frequency to check for new commands, based on number of iterations.
    Should be a multiple of summary_frequency.
    """
    def __init__(
        self,
        *,
        ga_config: global___BatchedMEParameters | None = ...,
        loadflow_solver_config: global___LoadflowSolverParameters | None = ...,
        double_limits: toop_engine_interfaces.messages.protobuf_schema.optimizer.ac_dc_commons_pb2.DoubleLimitsSetpoint | None = ...,
        summary_frequency: builtins.int = ...,
        check_command_frequency: builtins.int = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["double_limits", b"double_limits", "ga_config", b"ga_config", "loadflow_solver_config", b"loadflow_solver_config"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["check_command_frequency", b"check_command_frequency", "double_limits", b"double_limits", "ga_config", b"ga_config", "loadflow_solver_config", b"loadflow_solver_config", "summary_frequency", b"summary_frequency"]) -> None: ...

global___DCOptimizerParameters = DCOptimizerParameters
